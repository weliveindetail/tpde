; NOTE: Assertions have been autogenerated by test/update_tpde_llc_test_checks.py UTC_ARGS: --version 5
; SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
;
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde-llc --target=x86_64 %s | %objdump | FileCheck %s -check-prefixes=X64
; RUN: tpde-llc --target=aarch64 %s | %objdump | FileCheck %s -check-prefixes=ARM64


declare void @fn_void_void();
declare i32 @fn_i32_void();
declare i128 @fn_i128_void();

declare void @fn_void_i32(i32);
declare i32 @fn_i32_i32_i32(i32, i32);

declare i32 @fn_i32_i32_i128_i128_i128(i32, i128, i128, i128);
declare i32 @fn_i32_i128_i128_i128_i32(i32, i128, i128, i128, i32);
declare i32 @fn_i32_i128_i128_i32_i128_i32(i32, i128, i128, i32, i128, i32);
declare i32 @fn_i128_i128_i128_i32_i128(i128, i128, i128, i32, i128);
declare i32 @fn_i128_i128_i128_i128_i32_i128(i128, i128, i128, i128, i32, i128);

declare i32 @fn_var_arg(ptr, ...);


define void @call_void_void() {
; X64-LABEL: <call_void_void>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_void_void-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_void_void>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0x30 <call_void_void+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_void_void
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  call void @fn_void_void()
  ret void
}

define i32 @call_i32_void() {
; X64-LABEL: <call_i32_void>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_void-0x4
; X64-NEXT:    lea eax, [rax + 0xa]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i32_void>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0xa0 <call_i32_void+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_void
; ARM64-NEXT:    add w0, w0, #0xa
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %0 = call i32 @fn_i32_void()
  %1 = add i32 %0, 10
  ret i32 %1
}

define i128 @call_i128_void() {
; X64-LABEL: <call_i128_void>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_void-0x4
; X64-NEXT:    add rax, 0xa
; X64-NEXT:    adc rdx, 0x0
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_void>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0x110 <call_i128_void+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_void
; ARM64-NEXT:    adds x0, x0, #0xa
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    adc x2, x2, x1
; ARM64-NEXT:    mov x1, x2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %0 = call i128 @fn_i128_void()
  %1 = add i128 %0, 10
  ret i128 %1
}

define i32 @call_i128_void_ret_i32(i32 %0) {
; X64-LABEL: <call_i128_void_ret_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_void-0x4
; X64-NEXT:    add rax, 0xa
; X64-NEXT:    adc rdx, 0x0
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_void_ret_i32>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    bl 0x194 <call_i128_void_ret_i32+0x14>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_void
; ARM64-NEXT:    adds x0, x0, #0xa
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    adc x2, x2, x1
; ARM64-NEXT:    ldr w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %1 = call i128 @fn_i128_void()
  %2 = add i128 %1, 10
  ret i32 %0
}

define i32 @call_void_i32(i32 %0, i32 %1) {
; X64-LABEL: <call_void_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov edi, esi
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_void_i32-0x4
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_void_i32>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    bl 0x218 <call_void_i32+0x18>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_void_i32
; ARM64-NEXT:    ldr w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  call void @fn_void_i32(i32 %1)
  ret i32 %0
}

define void @call_void_i32_mismatch(i32 %0, i32 %1) {
; X64-LABEL: <call_void_i32_mismatch>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_void_i32-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_void_i32_mismatch>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0x280 <call_void_i32_mismatch+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_void_i32
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  call void (i32, i32) @fn_void_i32(i32 %0, i32 %1)
  ret void
}

define i32 @call_i32_i32_i32(i32 %0, i32 %1) {
; X64-LABEL: <call_i32_i32_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov edi, esi
; X64-NEXT:    mov esi, dword ptr [rbp - 0x2c]
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_i32_i32-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i32_i32_i32>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    ldr w1, [x29, #0xa0]
; ARM64-NEXT:    bl 0x2fc <call_i32_i32_i32+0x1c>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_i32_i32
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i32_i32_i32(i32 %1, i32 %0)
  ret i32 %2
}

define i32 @call_i32_i32_i128_i128_i128(i32 %0, i128 %1) {
; X64-LABEL: <call_i32_i32_i128_i128_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x38]
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_i32_i128_i128_i128-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i32_i32_i128_i128_i128>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x2, [x29, #0xa0]
; ARM64-NEXT:    str x3, [x29, #0xa8]
; ARM64-NEXT:    ldr x4, [x29, #0xa0]
; ARM64-NEXT:    ldr x5, [x29, #0xa8]
; ARM64-NEXT:    ldr x6, [x29, #0xa0]
; ARM64-NEXT:    ldr x7, [x29, #0xa8]
; ARM64-NEXT:    bl 0x378 <call_i32_i32_i128_i128_i128+0x28>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_i32_i128_i128_i128
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i32_i32_i128_i128_i128(i32 %0, i128 %1, i128 %1, i128 %1)
  ret i32 %2
}

define i32 @call_i32_i128_i128_i128_i32(i32 %0, i128 %1) {
; X64-LABEL: <call_i32_i128_i128_i128_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x38]
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:    mov r9d, dword ptr [rbp - 0x2c]
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_i128_i128_i128_i32-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i32_i128_i128_i128_i32>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    str x2, [x29, #0xb0]
; ARM64-NEXT:    str x3, [x29, #0xb8]
; ARM64-NEXT:    ldr x4, [x29, #0xb0]
; ARM64-NEXT:    ldr x5, [x29, #0xb8]
; ARM64-NEXT:    ldr x6, [x29, #0xb0]
; ARM64-NEXT:    ldr x7, [x29, #0xb8]
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    ldr w1, [x29, #0xa0]
; ARM64-NEXT:    str w1, [sp]
; ARM64-NEXT:    bl 0x408 <call_i32_i128_i128_i128_i32+0x38>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_i128_i128_i128_i32
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i32_i128_i128_i128_i32(i32 %0, i128 %1, i128 %1, i128 %1, i32 %0)
  ret i32 %2
}

define i32 @ret_i32_i128_i128_i128_i32(i32 %0, i128 %1, i128 %2, i128 %3, i32 %4) {
; X64-LABEL: <ret_i32_i128_i128_i128_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x18]
; X64-NEXT:    mov eax, r9d
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i32_i128_i128_i128_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr w0, [x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  ret i32 %4
}

define i32 @call_i32_i128_i128_i32_i128_i32(i32 %0, i128 %1) {
; X64-LABEL: <call_i32_i128_i128_i32_i128_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x38]
; X64-NEXT:    mov r9d, dword ptr [rbp - 0x2c]
; X64-NEXT:    sub rsp, 0x20
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    mov dword ptr [rsp + 0x10], eax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_i128_i128_i128_i32-0x4
; X64-NEXT:    add rsp, 0x20
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i32_i128_i128_i32_i128_i32>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    str x2, [x29, #0xb0]
; ARM64-NEXT:    str x3, [x29, #0xb8]
; ARM64-NEXT:    ldr x4, [x29, #0xb0]
; ARM64-NEXT:    ldr x5, [x29, #0xb8]
; ARM64-NEXT:    ldr w6, [x29, #0xa0]
; ARM64-NEXT:    sub sp, sp, #0x20
; ARM64-NEXT:    ldr x1, [x29, #0xb0]
; ARM64-NEXT:    str x1, [sp]
; ARM64-NEXT:    ldr x1, [x29, #0xb8]
; ARM64-NEXT:    str x1, [sp, #0x8]
; ARM64-NEXT:    ldr w1, [x29, #0xa0]
; ARM64-NEXT:    str w1, [sp, #0x10]
; ARM64-NEXT:    bl 0x514 <call_i32_i128_i128_i32_i128_i32+0x44>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_i128_i128_i128_i32
; ARM64-NEXT:    add sp, sp, #0x20
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i32_i128_i128_i128_i32(i32 %0, i128 %1, i128 %1, i32 %0, i128 %1, i32 %0)
  ret i32 %2
}

; COM: check alignment of i128
define i32 @call_i128_i128_i128_i32_i128(i32 %0, i128 %1) {
; X64-LABEL: <call_i128_i128_i128_i32_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov rdi, rsi
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov rsi, rdx
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rdx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r9, qword ptr [rbp - 0x38]
; X64-NEXT:    sub rsp, 0x20
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    mov dword ptr [rsp], eax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp + 0x10], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x18], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_i128_i128_i32_i128-0x4
; X64-NEXT:    add rsp, 0x20
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_i128_i128_i32_i128>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    mov x1, x3
; ARM64-NEXT:    str x2, [x29, #0xb0]
; ARM64-NEXT:    str x3, [x29, #0xb8]
; ARM64-NEXT:    ldr x4, [x29, #0xb0]
; ARM64-NEXT:    ldr x5, [x29, #0xb8]
; ARM64-NEXT:    ldr w6, [x29, #0xa0]
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    ldr x7, [x29, #0xb0]
; ARM64-NEXT:    str x7, [sp]
; ARM64-NEXT:    ldr x7, [x29, #0xb8]
; ARM64-NEXT:    str x7, [sp, #0x8]
; ARM64-NEXT:    bl 0x5b4 <call_i128_i128_i128_i32_i128+0x44>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_i128_i128_i32_i128
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i128_i128_i128_i32_i128(i128 %1, i128 %1, i128 %1, i32 %0, i128 %1)
  ret i32 %2
}

define i32 @call_i128_i128_i128_i128_i32_i128(i32 %0, i128 %1) {
; X64-LABEL: <call_i128_i128_i128_i128_i32_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov rdi, rsi
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov rsi, rdx
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rdx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r9, qword ptr [rbp - 0x38]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov rbx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rbx
; X64-NEXT:    mov r10d, dword ptr [rbp - 0x2c]
; X64-NEXT:    mov dword ptr [rsp + 0x10], r10d
; X64-NEXT:    mov qword ptr [rsp + 0x20], rax
; X64-NEXT:    mov qword ptr [rsp + 0x28], rbx
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_i128_i128_i128_i32_i128-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_i128_i128_i128_i32_i128>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    mov x1, x3
; ARM64-NEXT:    str x2, [x29, #0xb0]
; ARM64-NEXT:    str x3, [x29, #0xb8]
; ARM64-NEXT:    ldr x4, [x29, #0xb0]
; ARM64-NEXT:    ldr x5, [x29, #0xb8]
; ARM64-NEXT:    ldr x6, [x29, #0xb0]
; ARM64-NEXT:    ldr x7, [x29, #0xb8]
; ARM64-NEXT:    sub sp, sp, #0x20
; ARM64-NEXT:    ldr w8, [x29, #0xa0]
; ARM64-NEXT:    str w8, [sp]
; ARM64-NEXT:    ldr x8, [x29, #0xb0]
; ARM64-NEXT:    str x8, [sp, #0x10]
; ARM64-NEXT:    ldr x8, [x29, #0xb8]
; ARM64-NEXT:    str x8, [sp, #0x18]
; ARM64-NEXT:    bl 0x660 <call_i128_i128_i128_i128_i32_i128+0x50>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_i128_i128_i128_i32_i128
; ARM64-NEXT:    add sp, sp, #0x20
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i128_i128_i128_i128_i32_i128(i128 %1, i128 %1, i128 %1, i128 %1, i32 %0, i128 %1)
  ret i32 %2
}

define i128 @ret_i128_i128_i128_i32_i128(i128 %0, i128 %1, i128 %2, i32 %3, i128 %4) {
; X64-LABEL: <ret_i128_i128_i128_i32_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x20]
; X64-NEXT:    mov rcx, qword ptr [rbp + 0x28]
; X64-NEXT:    mov rdx, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i128_i128_i128_i32_i128>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr x0, [x8]
; ARM64-NEXT:    ldr x1, [x8, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  ret i128 %4
}

define i128 @ret_i128_i128_i128_i128_i32_i128(i128 %0, i128 %1, i128 %2, i128 %3, i32 %4, i128 %5) {
; X64-LABEL: <ret_i128_i128_i128_i128_i32_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x18]
; X64-NEXT:    mov eax, dword ptr [rbp + 0x20]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x30]
; X64-NEXT:    mov rcx, qword ptr [rbp + 0x38]
; X64-NEXT:    mov rdx, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i128_i128_i128_i128_i32_i128>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr w0, [x8]
; ARM64-NEXT:    ldr x0, [x8, #0x10]
; ARM64-NEXT:    ldr x1, [x8, #0x18]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  ret i128 %5
}

; COM: Check splitting of aggregates
%struct.tmp = type { i64, i64 }

declare i32 @fn_i128_i128_i32_tmp(i128, i128, i32, %struct.tmp);
declare i32 @fn_i128_i128_i128_i32_tmp(i128, i128, i128, i32, %struct.tmp);

define i32 @call_i128_i128_i32_tmp(i128 %0, i32 %1, %struct.tmp %2) {
; X64-LABEL: <call_i128_i128_i32_tmp>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x60
; X64-NEXT:    mov qword ptr [rbp - 0x40], rdi
; X64-NEXT:    mov qword ptr [rbp - 0x38], rsi
; X64-NEXT:    mov dword ptr [rbp - 0x44], edx
; X64-NEXT:    mov rdx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rbp - 0x60], rcx
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rbp - 0x58], r8
; X64-NEXT:    mov r8d, dword ptr [rbp - 0x44]
; X64-NEXT:    mov r9, qword ptr [rbp - 0x60]
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    mov rax, qword ptr [rbp - 0x58]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_i128_i32_tmp-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x60
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_i128_i32_tmp>:
; ARM64:         sub sp, sp, #0xd0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    str x1, [x29, #0xa8]
; ARM64-NEXT:    str w2, [x29, #0xb0]
; ARM64-NEXT:    ldr x2, [x29, #0xa0]
; ARM64-NEXT:    str x3, [x29, #0xc0]
; ARM64-NEXT:    ldr x3, [x29, #0xa8]
; ARM64-NEXT:    str x4, [x29, #0xc8]
; ARM64-NEXT:    ldr w4, [x29, #0xb0]
; ARM64-NEXT:    ldr x5, [x29, #0xc0]
; ARM64-NEXT:    ldr x6, [x29, #0xc8]
; ARM64-NEXT:    bl 0x7d8 <call_i128_i128_i32_tmp+0x38>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_i128_i32_tmp
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xd0
; ARM64-NEXT:    ret
entry:
  %3 = call i32 @fn_i128_i128_i32_tmp(i128 %0, i128 %0, i32 %1, %struct.tmp %2)
  ret i32 %3
}

define i32 @call_i128_i128_i128_i32_tmp(i128 %0, i32 %1, %struct.tmp %2) {
; X64-LABEL: <call_i128_i128_i128_i32_tmp>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x60
; X64-NEXT:    mov qword ptr [rbp - 0x40], rdi
; X64-NEXT:    mov qword ptr [rbp - 0x38], rsi
; X64-NEXT:    mov dword ptr [rbp - 0x44], edx
; X64-NEXT:    mov rdx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rbp - 0x60], rcx
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rbp - 0x58], r8
; X64-NEXT:    mov r8, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r9, qword ptr [rbp - 0x38]
; X64-NEXT:    sub rsp, 0x20
; X64-NEXT:    mov eax, dword ptr [rbp - 0x44]
; X64-NEXT:    mov dword ptr [rsp], eax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x60]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x58]
; X64-NEXT:    mov qword ptr [rsp + 0x10], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_i128_i128_i32_tmp-0x4
; X64-NEXT:    add rsp, 0x20
; X64-NEXT:    add rsp, 0x60
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_i128_i128_i32_tmp>:
; ARM64:         sub sp, sp, #0xd0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    str x1, [x29, #0xa8]
; ARM64-NEXT:    str w2, [x29, #0xb0]
; ARM64-NEXT:    ldr x2, [x29, #0xa0]
; ARM64-NEXT:    str x3, [x29, #0xc0]
; ARM64-NEXT:    ldr x3, [x29, #0xa8]
; ARM64-NEXT:    str x4, [x29, #0xc8]
; ARM64-NEXT:    ldr x4, [x29, #0xa0]
; ARM64-NEXT:    ldr x5, [x29, #0xa8]
; ARM64-NEXT:    ldr w6, [x29, #0xb0]
; ARM64-NEXT:    ldr x7, [x29, #0xc0]
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    ldr x8, [x29, #0xc8]
; ARM64-NEXT:    str x8, [sp]
; ARM64-NEXT:    bl 0x878 <call_i128_i128_i128_i32_tmp+0x48>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_i128_i128_i32_tmp
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xd0
; ARM64-NEXT:    ret
entry:
  %3 = call i32 @fn_i128_i128_i128_i32_tmp(i128 %0, i128 %0, i128 %0, i32 %1, %struct.tmp %2)
  ret i32 %3
}

define i64 @ret_i128_i128_i32_tmp_0(i128 %0, i128 %1, i32 %2, %struct.tmp %3) {
; X64-LABEL: <ret_i128_i128_i32_tmp_0>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, r9
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i128_i128_i32_tmp_0>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x0, x5
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %4 = extractvalue %struct.tmp %3, 0
  ret i64 %4
}

define i64 @ret_i128_i128_i32_tmp_1(i128 %0, i128 %1, i32 %2, %struct.tmp %3) {
; X64-LABEL: <ret_i128_i128_i32_tmp_1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i128_i128_i32_tmp_1>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x0, x6
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %4 = extractvalue %struct.tmp %3, 1
  ret i64 %4
}

define i64 @ret_i128_i128_i128_i32_tmp_0(i128 %0, i128 %1, i128 %2, i32 %3, %struct.tmp %4) {
; X64-LABEL: <ret_i128_i128_i128_i32_tmp_0>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x18]
; X64-NEXT:    mov rcx, qword ptr [rbp + 0x20]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i128_i128_i128_i32_tmp_0>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr x0, [x8]
; ARM64-NEXT:    mov x0, x7
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %5 = extractvalue %struct.tmp %4, 0
  ret i64 %5
}

define i64 @ret_i128_i128_i128_i32_tmp_1(i128 %0, i128 %1, i128 %2, i32 %3, %struct.tmp %4) {
; X64-LABEL: <ret_i128_i128_i128_i32_tmp_1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x18]
; X64-NEXT:    mov rcx, qword ptr [rbp + 0x20]
; X64-NEXT:    mov rax, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i128_i128_i128_i32_tmp_1>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr x0, [x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %5 = extractvalue %struct.tmp %4, 1
  ret i64 %5
}

define i32 @call_i32_vararg(ptr %0, i32 %1, i128 %2) {
; X64-LABEL: <call_i32_vararg>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rbp - 0x2c], esi
; X64-NEXT:    mov rsi, rdx
; X64-NEXT:    mov rdx, rcx
; X64-NEXT:    mov ecx, dword ptr [rbp - 0x2c]
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_var_arg-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i32_vararg>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w4, w1
; ARM64-NEXT:    bl 0xaa4 <call_i32_vararg+0x14>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_var_arg
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
    %3 = call i32 (ptr, ...) @fn_var_arg(ptr %0, i128 %2, i32 %1)
    ret i32 %3
}

define i32 @call_indirect(ptr %0) {
; X64-LABEL: <call_indirect>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov qword ptr [rbp - 0x30], rdi
; X64-NEXT:    mov edi, 0xa
; X64-NEXT:    mov r10, qword ptr [rbp - 0x30]
; X64-NEXT:    call r10
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_indirect>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    mov x0, #0xa // =10
; ARM64-NEXT:    ldr x16, [x29, #0xa0]
; ARM64-NEXT:    blr x16
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %1 = call i32 (i32) %0 (i32 10)
  ret i32 %1
}

define i32 @call_indirect2(i32 %i, ptr %f) {
; X64-LABEL: <call_indirect2>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov qword ptr [rbp - 0x30], rsi
; X64-NEXT:    mov r10, qword ptr [rbp - 0x30]
; X64-NEXT:    call r10
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_indirect2>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x1, [x29, #0xa0]
; ARM64-NEXT:    ldr x16, [x29, #0xa0]
; ARM64-NEXT:    blr x16
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
  %r = call i32 (i32) %f (i32 %i)
  ret i32 %r
}

define i32 @call_indirect3(ptr %m) {
; X64-LABEL: <call_indirect3>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x28
; X64-NEXT:    mov rdi, qword ptr [rdi]
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov edi, 0x0
; X64-NEXT:    mov r10, rbx
; X64-NEXT:    call r10
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    add rsp, 0x28
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_indirect3>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    ldr x0, [x0]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov x16, x19
; ARM64-NEXT:    blr x16
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  %ld = load ptr, ptr %m, align 8
  br label %bb

bb:
  call void %ld(ptr null)
  ret i32 0
}

%struct.ptr_i32 = type { ptr, i32 }
define i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %0, i32 %1) {
; X64-LABEL: <fn_i32_byval_ptr_i32_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    lea rax, [rbp + 0x10]
; X64-NEXT:    mov ecx, dword ptr [rax + 0x8]
; X64-NEXT:    lea ecx, [rcx + rdi]
; X64-NEXT:    mov eax, ecx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fn_i32_byval_ptr_i32_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    add x9, x8, #0x0
; ARM64-NEXT:    ldr w1, [x9, #0x8]
; ARM64-NEXT:    add w0, w0, w1
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %addr = getelementptr %struct.ptr_i32, ptr %0, i64 0, i32 1
  %val = load i32, ptr %addr
  %res = add i32 %val, %1
  ret i32 %res
}

; Check splitting of [2 x i64]
declare i32 @fn_i64_i64_i64_i64_i64_2xi64(i64, i64, i64, i64, i64, [2 x i64]);
define i32 @call_i64_i64_i64_i64_i64_2xi64(i64 %0, [2 x i64] %1) {
; X64-LABEL: <call_i64_i64_i64_i64_i64_2xi64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov qword ptr [rbp - 0x30], rdi
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov rsi, qword ptr [rbp - 0x30]
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rdx, qword ptr [rbp - 0x30]
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x30]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x30]
; X64-NEXT:    mov r9, qword ptr [rbp - 0x40]
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i64_i64_i64_i64_i64_2xi64-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i64_i64_i64_i64_i64_2xi64>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    str x1, [x29, #0xb0]
; ARM64-NEXT:    ldr x1, [x29, #0xa0]
; ARM64-NEXT:    str x2, [x29, #0xb8]
; ARM64-NEXT:    ldr x2, [x29, #0xa0]
; ARM64-NEXT:    ldr x3, [x29, #0xa0]
; ARM64-NEXT:    ldr x4, [x29, #0xa0]
; ARM64-NEXT:    ldr x5, [x29, #0xb0]
; ARM64-NEXT:    ldr x6, [x29, #0xb8]
; ARM64-NEXT:    bl 0xd04 <call_i64_i64_i64_i64_i64_2xi64+0x34>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i64_i64_i64_i64_i64_2xi64
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i64_i64_i64_i64_i64_2xi64(i64 %0, i64 %0, i64 %0, i64 %0, i64 %0, [2 x i64] %1)
  ret i32 %2
}

define void @fn_v_a3f64(ptr %d, [3 x double] %a) {
; X64-LABEL: <fn_v_a3f64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd qword ptr [rdi], xmm0
; X64-NEXT:    movsd qword ptr [rdi + 0x8], xmm1
; X64-NEXT:    movsd qword ptr [rdi + 0x10], xmm2
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fn_v_a3f64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str d0, [x0]
; ARM64-NEXT:    str d1, [x0, #0x8]
; ARM64-NEXT:    str d2, [x0, #0x10]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  store volatile [3 x double] %a, ptr %d
  ret void
}
define void @call_v_a3f64(ptr %p, ptr %d) {
; X64-LABEL: <call_v_a3f64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd xmm0, qword ptr [rdi]
; X64-NEXT:    movsd xmm1, qword ptr [rdi + 0x8]
; X64-NEXT:    movsd xmm2, qword ptr [rdi + 0x10]
; X64-NEXT:    mov rdi, rsi
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_v_a3f64-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_v_a3f64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr d0, [x0]
; ARM64-NEXT:    ldr d1, [x0, #0x8]
; ARM64-NEXT:    ldr d2, [x0, #0x10]
; ARM64-NEXT:    mov x0, x1
; ARM64-NEXT:    bl 0xdf0 <call_v_a3f64+0x20>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_v_a3f64
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  %a1 = load [3 x double], ptr %p
  call void @fn_v_a3f64(ptr %d, [3 x double] %a1)
  ret void
}

define void @fn_v_a3f64_a3f64(ptr %d, [3 x double] %a, [3 x double] %b) {
; X64-LABEL: <fn_v_a3f64_a3f64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd qword ptr [rdi], xmm0
; X64-NEXT:    movsd qword ptr [rdi + 0x8], xmm1
; X64-NEXT:    movsd qword ptr [rdi + 0x10], xmm2
; X64-NEXT:    movsd qword ptr [rdi], xmm3
; X64-NEXT:    movsd qword ptr [rdi + 0x8], xmm4
; X64-NEXT:    movsd qword ptr [rdi + 0x10], xmm5
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fn_v_a3f64_a3f64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str d0, [x0]
; ARM64-NEXT:    str d1, [x0, #0x8]
; ARM64-NEXT:    str d2, [x0, #0x10]
; ARM64-NEXT:    str d3, [x0]
; ARM64-NEXT:    str d4, [x0, #0x8]
; ARM64-NEXT:    str d5, [x0, #0x10]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  store volatile [3 x double] %a, ptr %d
  store volatile [3 x double] %b, ptr %d
  ret void
}
define void @call_v_a3f64_a3f64(ptr %p, ptr %q, ptr %d) {
; X64-LABEL: <call_v_a3f64_a3f64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd xmm0, qword ptr [rdi]
; X64-NEXT:    movsd xmm1, qword ptr [rdi + 0x8]
; X64-NEXT:    movsd xmm2, qword ptr [rdi + 0x10]
; X64-NEXT:    movsd xmm3, qword ptr [rsi]
; X64-NEXT:    movsd xmm4, qword ptr [rsi + 0x8]
; X64-NEXT:    movsd xmm5, qword ptr [rsi + 0x10]
; X64-NEXT:    mov rdi, rdx
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_v_a3f64_a3f64-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_v_a3f64_a3f64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr d0, [x0]
; ARM64-NEXT:    ldr d1, [x0, #0x8]
; ARM64-NEXT:    ldr d2, [x0, #0x10]
; ARM64-NEXT:    ldr d3, [x1]
; ARM64-NEXT:    ldr d4, [x1, #0x8]
; ARM64-NEXT:    ldr d5, [x1, #0x10]
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    bl 0xefc <call_v_a3f64_a3f64+0x2c>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_v_a3f64_a3f64
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  %a1 = load [3 x double], ptr %p
  %a2 = load [3 x double], ptr %q
  call void @fn_v_a3f64_a3f64(ptr %d, [3 x double] %a1, [3 x double] %a2)
  ret void
}

define void @fn_v_a3f64_a3f64_a3f64(ptr %d, [3 x double] %a, [3 x double] %b, [3 x double] %c) {
; X64-LABEL: <fn_v_a3f64_a3f64_a3f64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movq xmm8, qword ptr [rbp + 0x10]
; X64-NEXT:    movsd qword ptr [rdi], xmm0
; X64-NEXT:    movsd qword ptr [rdi + 0x8], xmm1
; X64-NEXT:    movsd qword ptr [rdi + 0x10], xmm2
; X64-NEXT:    movsd qword ptr [rdi], xmm3
; X64-NEXT:    movsd qword ptr [rdi + 0x8], xmm4
; X64-NEXT:    movsd qword ptr [rdi + 0x10], xmm5
; X64-NEXT:    movsd qword ptr [rdi], xmm6
; X64-NEXT:    movsd qword ptr [rdi + 0x8], xmm7
; X64-NEXT:    movsd qword ptr [rdi + 0x10], xmm8
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fn_v_a3f64_a3f64_a3f64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str d8, [sp, #0x10]
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr d8, [x8]
; ARM64-NEXT:    str d0, [x0]
; ARM64-NEXT:    str d1, [x0, #0x8]
; ARM64-NEXT:    str d2, [x0, #0x10]
; ARM64-NEXT:    str d3, [x0]
; ARM64-NEXT:    str d4, [x0, #0x8]
; ARM64-NEXT:    str d5, [x0, #0x10]
; ARM64-NEXT:    str d6, [x0]
; ARM64-NEXT:    str d7, [x0, #0x8]
; ARM64-NEXT:    str d8, [x0, #0x10]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr d8, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  store volatile [3 x double] %a, ptr %d
  store volatile [3 x double] %b, ptr %d
  store volatile [3 x double] %c, ptr %d
  ret void
}
define void @call_v_a3f64_a3f64_a3f64(ptr %p, ptr %q, ptr %s, ptr %d) {
; X64-LABEL: <call_v_a3f64_a3f64_a3f64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd xmm0, qword ptr [rdi]
; X64-NEXT:    movsd xmm1, qword ptr [rdi + 0x8]
; X64-NEXT:    movsd xmm2, qword ptr [rdi + 0x10]
; X64-NEXT:    movsd xmm3, qword ptr [rsi]
; X64-NEXT:    movsd xmm4, qword ptr [rsi + 0x8]
; X64-NEXT:    movsd xmm5, qword ptr [rsi + 0x10]
; X64-NEXT:    movsd xmm6, qword ptr [rdx]
; X64-NEXT:    movsd xmm7, qword ptr [rdx + 0x8]
; X64-NEXT:    movsd xmm8, qword ptr [rdx + 0x10]
; X64-NEXT:    mov rdi, rcx
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    movsd qword ptr [rsp], xmm8
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_v_a3f64_a3f64_a3f64-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_v_a3f64_a3f64_a3f64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str d8, [sp, #0x10]
; ARM64-NEXT:    ldr d0, [x0]
; ARM64-NEXT:    ldr d1, [x0, #0x8]
; ARM64-NEXT:    ldr d2, [x0, #0x10]
; ARM64-NEXT:    ldr d3, [x1]
; ARM64-NEXT:    ldr d4, [x1, #0x8]
; ARM64-NEXT:    ldr d5, [x1, #0x10]
; ARM64-NEXT:    ldr d6, [x2]
; ARM64-NEXT:    ldr d7, [x2, #0x8]
; ARM64-NEXT:    ldr d8, [x2, #0x10]
; ARM64-NEXT:    mov x0, x3
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    str d8, [sp]
; ARM64-NEXT:    bl 0x1020 <call_v_a3f64_a3f64_a3f64+0x40>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_v_a3f64_a3f64_a3f64
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr d8, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  %a1 = load [3 x double], ptr %p
  %a2 = load [3 x double], ptr %q
  %a3 = load [3 x double], ptr %s
  call void @fn_v_a3f64_a3f64_a3f64(ptr %d, [3 x double] %a1, [3 x double] %a2, [3 x double] %a3)
  ret void
}

declare i32 @fn_i64_i64_i64_i64_i64_i64_i64_2xi64(i64, i64, i64, i64, i64, i64, i64, [2 x i64]);
define i32 @call_i64_i64_i64_i64_i64_i64_i64_2xi64(i64 %0, [2 x i64] %1) {
; X64-LABEL: <call_i64_i64_i64_i64_i64_i64_i64_2xi64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov qword ptr [rbp - 0x30], rdi
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov rsi, qword ptr [rbp - 0x30]
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rdx, qword ptr [rbp - 0x30]
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x30]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x30]
; X64-NEXT:    mov r9, qword ptr [rbp - 0x30]
; X64-NEXT:    sub rsp, 0x20
; X64-NEXT:    mov rax, qword ptr [rbp - 0x30]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x10], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i64_i64_i64_i64_i64_i64_i64_2xi64-0x4
; X64-NEXT:    add rsp, 0x20
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i64_i64_i64_i64_i64_i64_i64_2xi64>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    str x1, [x29, #0xb0]
; ARM64-NEXT:    ldr x1, [x29, #0xa0]
; ARM64-NEXT:    str x2, [x29, #0xb8]
; ARM64-NEXT:    ldr x2, [x29, #0xa0]
; ARM64-NEXT:    ldr x3, [x29, #0xa0]
; ARM64-NEXT:    ldr x4, [x29, #0xa0]
; ARM64-NEXT:    ldr x5, [x29, #0xa0]
; ARM64-NEXT:    ldr x6, [x29, #0xa0]
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    ldr x7, [x29, #0xb0]
; ARM64-NEXT:    str x7, [sp]
; ARM64-NEXT:    ldr x7, [x29, #0xb8]
; ARM64-NEXT:    str x7, [sp, #0x8]
; ARM64-NEXT:    bl 0x10c8 <call_i64_i64_i64_i64_i64_i64_i64_2xi64+0x48>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i64_i64_i64_i64_i64_i64_i64_2xi64
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i64_i64_i64_i64_i64_i64_i64_2xi64(i64 %0, i64 %0, i64 %0, i64 %0, i64 %0, i64 %0, i64 %0, [2 x i64] %1)
  ret i32 %2
}

define i64 @ret_i64_i64_i64_i64_i64_2xi64_0(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, [2 x i64] %5) {
; X64-LABEL: <ret_i64_i64_i64_i64_i64_2xi64_0>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, r9
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i64_i64_i64_i64_i64_2xi64_0>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x0, x5
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %6 = extractvalue [2 x i64] %5, 0
  ret i64 %6
}

define i64 @ret_i64_i64_i64_i64_i64_2xi64_1(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, [2 x i64] %5) {
; X64-LABEL: <ret_i64_i64_i64_i64_i64_2xi64_1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i64_i64_i64_i64_i64_2xi64_1>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x0, x6
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %6 = extractvalue [2 x i64] %5, 1
  ret i64 %6
}

define i64 @ret_i64_i64_i64_i64_i64_i64_i64_2xi64_0(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %z, i64 %y, [2 x i64] %5) {
; X64-LABEL: <ret_i64_i64_i64_i64_i64_i64_i64_2xi64_0>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x18]
; X64-NEXT:    mov rcx, qword ptr [rbp + 0x20]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i64_i64_i64_i64_i64_i64_i64_2xi64_0>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr x0, [x8]
; ARM64-NEXT:    ldr x1, [x8, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %6 = extractvalue [2 x i64] %5, 0
  ret i64 %6
}

define i64 @ret_i64_i64_i64_i64_i64_i64_i64_2xi64_1(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %z, i64 %y, [2 x i64] %5) {
; X64-LABEL: <ret_i64_i64_i64_i64_i64_i64_i64_2xi64_1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp + 0x10]
; X64-NEXT:    mov rax, qword ptr [rbp + 0x18]
; X64-NEXT:    mov rcx, qword ptr [rbp + 0x20]
; X64-NEXT:    mov rax, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ret_i64_i64_i64_i64_i64_i64_i64_2xi64_1>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xa0
; ARM64-NEXT:    ldr x0, [x8]
; ARM64-NEXT:    ldr x1, [x8, #0x8]
; ARM64-NEXT:    mov x0, x1
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %6 = extractvalue [2 x i64] %5, 1
  ret i64 %6
}

define i32 @call_byval(i32 %0) {
; X64-LABEL: <call_byval>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    lea rax, [rbp - 0x40]
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    mov rcx, qword ptr [rax]
; X64-NEXT:    mov qword ptr [rsp], rcx
; X64-NEXT:    mov rcx, qword ptr [rax + 0x8]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rcx
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_byval_ptr_i32_i32-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_byval>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x1, x29, #0xa0
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    ldr x16, [x1]
; ARM64-NEXT:    str x16, [sp]
; ARM64-NEXT:    ldr x16, [x1, #0x8]
; ARM64-NEXT:    str x16, [sp, #0x8]
; ARM64-NEXT:    bl 0x1308 <call_byval+0x28>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_byval_ptr_i32_i32
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %val = alloca %struct.ptr_i32, align 8
  %1 = call i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %val, i32 %0)
  ret i32 %1
}

%struct.3i64 = type { [3 x i64] }

define void @call_sret_tgt(ptr sret(%struct.3i64) align 8) {
; X64-LABEL: <call_sret_tgt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov qword ptr [rdi], 0x1
; X64-NEXT:    mov qword ptr [rdi + 0x8], 0x2
; X64-NEXT:    mov qword ptr [rdi + 0x10], 0x3
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_sret_tgt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x0, #0x1 // =1
; ARM64-NEXT:    str x0, [x8]
; ARM64-NEXT:    mov x0, #0x2 // =2
; ARM64-NEXT:    str x0, [x8, #0x8]
; ARM64-NEXT:    mov x0, #0x3 // =3
; ARM64-NEXT:    str x0, [x8, #0x10]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  %gep1 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 0
  store i64 1, ptr %gep1
  %gep2 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 1
  store i64 2, ptr %gep2
  %gep3 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 2
  store i64 3, ptr %gep3
  ret void
}

define void @call_sret() {
; X64-LABEL: <call_sret>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    lea rdi, [rbp - 0x50]
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 call_sret_tgt-0x4
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_sret>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, x29, #0xa0
; ARM64-NEXT:    bl 0x13f4 <call_sret+0x14>
; ARM64-NEXT:     R_AARCH64_CALL26 call_sret_tgt
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %1 = alloca %struct.3i64, align 8
  call void @call_sret_tgt(ptr sret(%struct.3i64) align 8 %1)
  ret void
}

declare void @call_sret_manyargs_tgt(ptr sret(%struct.3i64) align 8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr)

define void @call_sret_manyargs() {
; X64-LABEL: <call_sret_manyargs>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    lea rdi, [rbp - 0x50]
; X64-NEXT:    mov esi, 0x0
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    mov r8d, 0x0
; X64-NEXT:    mov r9d, 0x0
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp + 0x10], rax
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp + 0x18], rax
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp + 0x20], rax
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp + 0x28], rax
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov qword ptr [rsp + 0x30], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 call_sret_tgt-0x4
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_sret_manyargs>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, x29, #0xa0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    mov w3, #0x0 // =0
; ARM64-NEXT:    mov w4, #0x0 // =0
; ARM64-NEXT:    mov w5, #0x0 // =0
; ARM64-NEXT:    mov w6, #0x0 // =0
; ARM64-NEXT:    mov w7, #0x0 // =0
; ARM64-NEXT:    sub sp, sp, #0x20
; ARM64-NEXT:    mov w9, #0x0 // =0
; ARM64-NEXT:    str x9, [sp]
; ARM64-NEXT:    mov w9, #0x0 // =0
; ARM64-NEXT:    str x9, [sp, #0x8]
; ARM64-NEXT:    mov w9, #0x0 // =0
; ARM64-NEXT:    str x9, [sp, #0x10]
; ARM64-NEXT:    mov w9, #0x0 // =0
; ARM64-NEXT:    str x9, [sp, #0x18]
; ARM64-NEXT:    bl 0x14a8 <call_sret_manyargs+0x58>
; ARM64-NEXT:     R_AARCH64_CALL26 call_sret_tgt
; ARM64-NEXT:    add sp, sp, #0x20
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %1 = alloca %struct.3i64, align 8
  call void @call_sret_tgt(ptr sret(%struct.3i64) align 8 %1, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null)
  ret void
}

declare i32 @alloca_call_tgt(i32, ptr)
define i32 @alloca_call(i32 %a1, i32 %a2, i32 %a3, i32 %a4) {
; X64-LABEL: <alloca_call>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x138c0
; X64-NEXT:    mov edi, esi
; X64-NEXT:    mov dword ptr [rbp - 0x138b4], esi
; X64-NEXT:    lea rsi, [rbp - 0x138b0]
; X64-NEXT:    mov dword ptr [rbp - 0x138b8], ecx
; X64-NEXT:    mov dword ptr [rbp - 0x138bc], edx
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 alloca_call_tgt-0x4
; X64-NEXT:    mov ecx, dword ptr [rbp - 0x138b4]
; X64-NEXT:    lea ecx, [rcx + rax]
; X64-NEXT:    mov eax, dword ptr [rbp - 0x138bc]
; X64-NEXT:    mov edx, dword ptr [rbp - 0x138b8]
; X64-NEXT:    lea eax, [rax + rdx]
; X64-NEXT:    mov eax, ecx
; X64-NEXT:    add rsp, 0x138c0
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <alloca_call>:
; ARM64:         sub sp, sp, #0x14, lsl #12 // =0x14000
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    add x16, x29, #0x13, lsl #12 // =0x13000
; ARM64-NEXT:    str w1, [x16, #0x920]
; ARM64-NEXT:    add x1, x29, #0xa0
; ARM64-NEXT:    add x16, x29, #0x13, lsl #12 // =0x13000
; ARM64-NEXT:    str w2, [x16, #0x924]
; ARM64-NEXT:    add x16, x29, #0x13, lsl #12 // =0x13000
; ARM64-NEXT:    str w3, [x16, #0x928]
; ARM64-NEXT:    bl 0x1530 <alloca_call+0x30>
; ARM64-NEXT:     R_AARCH64_CALL26 alloca_call_tgt
; ARM64-NEXT:    add x1, x29, #0x13, lsl #12 // =0x13000
; ARM64-NEXT:    ldr w1, [x1, #0x920]
; ARM64-NEXT:    add w0, w0, w1
; ARM64-NEXT:    add x1, x29, #0x13, lsl #12 // =0x13000
; ARM64-NEXT:    ldr w1, [x1, #0x928]
; ARM64-NEXT:    add x2, x29, #0x13, lsl #12 // =0x13000
; ARM64-NEXT:    ldr w2, [x2, #0x924]
; ARM64-NEXT:    add w1, w1, w2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0x14, lsl #12 // =0x14000
; ARM64-NEXT:    ret
  %buf = alloca [80000 x i8]
  %c = call i32 @alloca_call_tgt(i32 %a2, ptr %buf)
  %r = add i32 %a2, %c
  %u1 = add i32 %a3, %a4
  ret i32 %r
}

define i32 @ind_call(ptr %call, i32 %a, i32 %b) {
; X64-LABEL: <ind_call>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov qword ptr [rbp - 0x30], rdi
; X64-NEXT:    mov r10, qword ptr [rbp - 0x30]
; X64-NEXT:    call r10
; X64-NEXT:    mov r10, qword ptr [rbp - 0x30]
; X64-NEXT:    call r10
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ind_call>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    ldr x16, [x29, #0xa0]
; ARM64-NEXT:    blr x16
; ARM64-NEXT:    ldr x16, [x29, #0xa0]
; ARM64-NEXT:    blr x16
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
  call void %call()
  call void %call()
  ret i32 0
}

declare void @fn_v_i8sext_i8sext_i8sext(i8 signext, i8 signext, i8 signext)
define i8 @call_fn_v_i8sext_i8sext_i8sext(i8 %a, i8 %b, i8 %c, i8 %d) {
; X64-LABEL: <call_fn_v_i8sext_i8sext_i8sext>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsx rdi, dil
; X64-NEXT:    movsx rsi, dl
; X64-NEXT:    mov edx, ecx
; X64-NEXT:    movsx rdx, dl
; X64-NEXT:    mov byte ptr [rbp - 0x29], cl
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_v_i8sext_i8sext_i8sext-0x4
; X64-NEXT:    movzx eax, byte ptr [rbp - 0x29]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_fn_v_i8sext_i8sext_i8sext>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    sxtb x0, w0
; ARM64-NEXT:    sxtb x1, w2
; ARM64-NEXT:    mov w2, w3
; ARM64-NEXT:    sxtb x2, w2
; ARM64-NEXT:    strb w3, [x29, #0xa0]
; ARM64-NEXT:    bl 0x1654 <call_fn_v_i8sext_i8sext_i8sext+0x24>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_v_i8sext_i8sext_i8sext
; ARM64-NEXT:    ldrb w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
  call void @fn_v_i8sext_i8sext_i8sext(i8 %a, i8 %c, i8 %d)
  ret i8 %d
}

declare void @fn_v_i8zext_i8zext_i8zext(i8 zeroext, i8 zeroext, i8 zeroext)
define i8 @call_fn_v_i8zext_i8zext_i8zext(i8 %a, i8 %b, i8 %c, i8 %d) {
; X64-LABEL: <call_fn_v_i8zext_i8zext_i8zext>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx edi, dil
; X64-NEXT:    movzx esi, dl
; X64-NEXT:    mov edx, ecx
; X64-NEXT:    movzx edx, dl
; X64-NEXT:    mov byte ptr [rbp - 0x29], cl
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_v_i8zext_i8zext_i8zext-0x4
; X64-NEXT:    movzx eax, byte ptr [rbp - 0x29]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_fn_v_i8zext_i8zext_i8zext>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ubfx x0, x0, #0, #8
; ARM64-NEXT:    ubfx x1, x2, #0, #8
; ARM64-NEXT:    mov w2, w3
; ARM64-NEXT:    ubfx x2, x2, #0, #8
; ARM64-NEXT:    strb w3, [x29, #0xa0]
; ARM64-NEXT:    bl 0x16d4 <call_fn_v_i8zext_i8zext_i8zext+0x24>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_v_i8zext_i8zext_i8zext
; ARM64-NEXT:    ldrb w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
  call void @fn_v_i8zext_i8zext_i8zext(i8 %a, i8 %c, i8 %d)
  ret i8 %d
}
